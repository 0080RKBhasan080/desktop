import { assertNever } from '../lib/fatal-error'

/** indicate what a line in the diff represents */
export enum DiffLineType {
  Context, Add, Delete, Hunk
}

/** track details related to each line in the diff */
export class DiffLine {
  public readonly text: string
  public readonly type: DiffLineType
  public readonly oldLineNumber: number | null
  public readonly newLineNumber: number | null
  public readonly noTrailingNewLine: boolean

  public constructor(text: string, type: DiffLineType, oldLineNumber: number | null, newLineNuber: number | null, noTrailingNewLine: boolean = false) {
    this.text = text
    this.type = type
    this.oldLineNumber = oldLineNumber
    this.newLineNumber = newLineNuber
    this.noTrailingNewLine = noTrailingNewLine
  }

  public withNoTrailingNewLine(noTrailingNewLine: boolean): DiffLine {
    return new DiffLine(this.text, this.type, this.oldLineNumber, this.newLineNumber, noTrailingNewLine)
  }
}

/** details about the start and end of a diff hunk */
export class DiffHunkHeader {
  /** The line in the old (or original) file where this diff hunk starts */
  public readonly oldStartLine: number

  /** The number of lines in the old (or original) file that this diff hunk covers */
  public readonly oldLineCount: number

  /** The line in the new file where this diff hunk starts */
  public readonly newStartLine: number

  /** The number of lines in the new file that this diff hunk covers */
  public readonly newLineCount: number

  public readonly sectionHeading: string | null

  public constructor(oldStartLine: number, oldLineCount: number, newStartLine: number, newLineCount: number, sectionHeading?: string | null) {
    this.oldStartLine = oldStartLine
    this.oldLineCount = oldLineCount
    this.newStartLine = newStartLine
    this.newLineCount = newLineCount
    this.sectionHeading = sectionHeading || null
  }
}

/** each diff is made up of a number of hunks */
export class DiffHunk {
  /** details from the diff hunk header about the line start and patch length */
  public readonly header: DiffHunkHeader
  /** the contents - context and changes - of the diff setion */
  public readonly lines: ReadonlyArray<DiffLine>
  /** the diff hunk's start position in the overall file diff */
  public readonly unifiedDiffStart: number
  /** the diff hunk's end position in the overall file diff */
  public readonly unifiedDiffEnd: number

  public constructor(header: DiffHunkHeader, lines: ReadonlyArray<DiffLine>, unifiedDiffStart: number, unifiedDiffEnd: number) {
    this.header = header
    this.unifiedDiffStart = unifiedDiffStart
    this.unifiedDiffEnd = unifiedDiffEnd
    this.lines = lines
  }
}

/** the contents of a diff generated by Git */
export class Diff {
   public readonly hunks: ReadonlyArray<DiffHunk>
   public readonly isBinary: boolean

   public constructor(hunks: ReadonlyArray<DiffHunk>, isBinary: boolean = false) {
     this.hunks = hunks
     this.isBinary = isBinary
   }

   /**
    * Locate the diff hunk for the given (absolute) line number in the
    * diff.
    */
   public diffHunkForIndex(index: number): DiffHunk | null {
     const hunk = this.hunks.find(h => {
       return index >= h.unifiedDiffStart && index <= h.unifiedDiffEnd
     })
     return hunk || null
   }
}

export enum DiffSelectionType {
  All,
  Partial,
  None
}

function typeMatchesSelection(selectionType: DiffSelectionType, selected: boolean): boolean {
  switch (selectionType) {
    case DiffSelectionType.All: return selected
    case DiffSelectionType.None: return !selected
    case DiffSelectionType.Partial: return false
    default:
      return assertNever(selectionType, `Unknown selection type ${selectionType}`)
  }
}

/**
 * An immutable, efficient, storage object for tracking selections of indexable
 * lines. While general purpose by design this is currently used exclusively for
 * tracking selected lines in modified files in the working directory.
 *
 * This class starts out with an initial (or default) selection state, ie
 * either all lines are selected by default or no lines are selected by default.
 *
 * The selection can then be transformed by marking a line or a range of lines
 * as selected or not selected. Internally the class maintains a list of lines
 * whose selection state has diverged from the default selection state.
 */
export class DiffSelection {

  private readonly defaultSelectionType: DiffSelectionType.All | DiffSelectionType.None

  private readonly divergingLines: Set<number> | null
  private readonly selectableLines: Set<number> | null

  public static fromInitialSelection(initialSelection: DiffSelectionType.All | DiffSelectionType.None): DiffSelection {

    if (initialSelection !== DiffSelectionType.All && initialSelection !== DiffSelectionType.None) {
      return assertNever(initialSelection, 'Can only instantiate a DiffSelection with All or None as the initial selection')
    }

    return new DiffSelection(initialSelection, null, null)
  }

  private constructor(defaultSelectionType: DiffSelectionType.All | DiffSelectionType.None, divergingLines: Set<number> | null, selectableLines: Set<number> | null) {
    this.defaultSelectionType = defaultSelectionType
    this.divergingLines = divergingLines || null
    this.selectableLines = selectableLines || null
  }

  /**  return the current state of the diff selection */
  public getSelectionType(): DiffSelectionType {
    if (!this.divergingLines || this.divergingLines.size === 0) {
      return this.defaultSelectionType
    } else {
      return DiffSelectionType.Partial
    }
  }

  public isSelected(rowIndex: number): boolean {
    const lineIsDivergent = !!this.divergingLines && this.divergingLines.has(rowIndex)

    if (this.defaultSelectionType === DiffSelectionType.All) {
      return !lineIsDivergent
    } else if (this.defaultSelectionType === DiffSelectionType.None) {
      return lineIsDivergent
    } else {
      return assertNever(this.defaultSelectionType, `Unknown base selection type ${this.defaultSelectionType}`)
    }
  }

  public isSelectable(rowIndex: number): boolean {
    return this.selectableLines
      ? this.selectableLines.has(rowIndex)
      : true
  }

  public withLineSelection(rowIndex: number, selected: boolean): DiffSelection {
    return this.withRangeSelection(rowIndex, 1, selected)
  }

  // Lower inclusive, upper exclusive. Same as substring
  public withRangeSelection(from: number, length: number, selected: boolean): DiffSelection {
    const computedSelectionType = this.getSelectionType()
    const to = from + length

    // Nothing for us to do here
    if (typeMatchesSelection(computedSelectionType, selected)) {
       return this
    }

    if (computedSelectionType === DiffSelectionType.Partial) {
      const newDivergingLines = new Set<number>(this.divergingLines!)

      if (typeMatchesSelection(this.defaultSelectionType, selected)) {
        for (let i = from; i < to; i++) {
          newDivergingLines.delete(i)
        }
      } else {
        for (let i = from; i < to; i++) {
          // Ensure it's selectable
          if (this.isSelectable(i)) {
            newDivergingLines.add(i)
          }
        }
      }

      return new DiffSelection(this.defaultSelectionType, newDivergingLines.size === 0 ? null : newDivergingLines, this.selectableLines)
    } else {
      const newDivergingLines = new Set<number>()
      for (let i = from; i < to; i++) {
        if (this.isSelectable(i)) {
          newDivergingLines.add(i)
        }
      }

      return new DiffSelection(computedSelectionType, newDivergingLines, this.selectableLines)
    }
  }

  public withToggleLineSelection(rowIndex: number): DiffSelection {
    return this.withLineSelection(rowIndex, !this.isSelected(rowIndex))
  }

  public withSelectAll(): DiffSelection {
    return new DiffSelection(DiffSelectionType.All, null, this.selectableLines)
  }

  public withSelectNone(): DiffSelection {
    return new DiffSelection(DiffSelectionType.None, null, this.selectableLines)
  }

  public withSelectableLines(selectableLines: Set<number>) {
    const divergingLines = this.divergingLines
      ? new Set([ ...this.divergingLines ].filter(x => selectableLines.has(x)))
      : null

    return new DiffSelection(this.defaultSelectionType, divergingLines, selectableLines)
  }
}

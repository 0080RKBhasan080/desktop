
/** indicate what a line in the diff represents */
export enum DiffLineType {
  Context, Add, Delete, Hunk
}

/** track details related to each line in the diff */
export class DiffLine {
  public readonly text: string
  public readonly type: DiffLineType
  public readonly oldLineNumber: number | null
  public readonly newLineNumber: number | null
  public selected: boolean = false

  public constructor(text: string, type: DiffLineType, oldLineNumber: number | null, newLineNuber: number | null) {
    this.text = text
    this.type = type
    this.oldLineNumber = oldLineNumber
    this.newLineNumber = newLineNuber
  }
}

/** details about the start and end of a section of a diff */
export class DiffSectionRange {
  public readonly oldStartLine: number
  public readonly oldEndLine: number
  public readonly newStartLine: number
  public readonly newEndLine: number

  public constructor(oldStartLine: number, oldEndLine: number, newStartLine: number, newEndLine: number) {
    this.oldStartLine = oldStartLine
    this.oldEndLine = oldEndLine
    this.newStartLine = newStartLine
    this.newEndLine = newEndLine
  }
}

/** each diff is made up of a number of sections */
export class DiffSection {
  /** details from the diff section about the line start and patch length */
  public readonly range: DiffSectionRange
  /** the contents - context and changes - of the diff setion */
  public readonly lines: ReadonlyArray<DiffLine>
  /** the diff section's start position in the overall file diff */
  public readonly unifiedDiffStart: number
  /** the diff section's end position in the overall file diff */
  public readonly unifiedDiffEnd: number

  /** infer the type of a diff line based on the prefix */
  private static mapToDiffLineType(text: string) {
    if (text.startsWith('-')) {
        return DiffLineType.Delete
    } else if (text.startsWith('+')) {
        return DiffLineType.Add
    } else {
        return DiffLineType.Context
    }
  }

  public constructor(range: DiffSectionRange, lines: string[], unifiedDiffStart: number, unifiedDiffEnd: number) {
    this.range = range
    this.unifiedDiffStart = unifiedDiffStart
    this.unifiedDiffEnd = unifiedDiffEnd

    let rollingDiffBeforeCounter = range.oldStartLine
    let rollingDiffAfterCounter = range.newStartLine

    const diffLines = lines.map(text => {
      // the unified patch format considers these lines to be headers
      // -> exclude them from the line counts
      if (text.startsWith('@@')) {
        return new DiffLine(text, DiffLineType.Hunk, null, null)
      }

      const type = DiffSection.mapToDiffLineType(text)

      if (type === DiffLineType.Delete) {
        return new DiffLine(text, type, rollingDiffBeforeCounter++, null)
      } else if (type === DiffLineType.Add) {
        return new DiffLine(text, type, null, rollingDiffAfterCounter++)
      } else {
        return new DiffLine(text, type, rollingDiffBeforeCounter++, rollingDiffAfterCounter++)
      }
    })

    this.lines = diffLines
  }
}

/** the contents of a diff generated by Git */
export class Diff {
   public readonly sections: ReadonlyArray<DiffSection>

   public constructor(sections: DiffSection[]) {
     this.sections = sections
   }

   public setAllLines(include: boolean) {
     this.sections
        .forEach(section => {
          section.lines.forEach(line => {
            if (line.type === DiffLineType.Add || line.type === DiffLineType.Delete) {
              line.selected = include
            }
          })
        })
   }
}

export enum DiffSelectionType {
  All,
  Partial,
  None
}

export class DiffSelectionParser {
  /** iterate over the selected values and determine the all/none state  */
  private static parse(selection: Map<number, boolean>): { allSelected: boolean, noneSelected: boolean } {
      const toArray = Array.from(selection.values())

      const allSelected = toArray.every(k => k === true)
      const noneSelected = toArray.every(k => k === false)

      return { allSelected, noneSelected }
  }

  /** determine the selection state based on the selected lines */
  public static getState(selection: Map<number, boolean>): DiffSelectionType {
    const { allSelected, noneSelected } = DiffSelectionParser.parse(selection)

    if (allSelected) {
      return DiffSelectionType.All
    } else if (noneSelected) {
      return DiffSelectionType.None
    }

    return  DiffSelectionType.Partial
  }
}


/** encapsulate the selection of changes to a modified file in the working directory  */
export class DiffSelection {

  /** by default, the diff selection to include all lines */
  private readonly include: DiffSelectionType = DiffSelectionType.All

  /**
   *  Once the user has started selecting specific lines to include,
   *  these selections are tracked here - the key corresponds to the index
   *  in the unified diff, and the value indicates whether the line has been
   *  selected
   *
   *  @TODO there's an impedance mismatch here between the diff hunk, which
   *        each have indexes relative to themselves and might not be unique,
   *        and the user selecting a line, which need to be unique. Pondering
   *        on a better way to represent this...
   */
  public readonly selectedLines: Map<number, boolean>

  public constructor(include: DiffSelectionType, selectedLines: Map<number, boolean>) {
    this.include = include
    this.selectedLines = selectedLines
  }

  /**  return the current state of the diff selection */
  public getSelectionType(): DiffSelectionType {
    if (this.selectedLines.size === 0) {
      return this.include
    } else {
      return DiffSelectionParser.getState(this.selectedLines)
    }
  }
}
